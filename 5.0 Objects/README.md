# Объекты
Объект - это составное значение: он агрегирует множество значений (элементарные значения или другие объекты) и позволяет хранить и извлекать внутренние значения по имени. Объект представляет собой неупорядоченную коллекцию свойств, каждое из которых имеет имя и значение.

## Создание объектов
Объекты можно создавать с помощью объектных литералов, ключевого слова new и функции Object.create().
- Объектные литералы - в своей простейшей форме объектный литерал представляет собой разделенный запятыми список пар имя:значение, заключенный в фигурные скобки. Имя свойства - это идентификатор JavaScript или строк (допускается и пустая строка). Значение свойства - это любое выражение JavaScript; значение выражения становится значением свойства.
- Создание объектов с помощью операции new - Операция new создает и инициализирует новый объект. За ключевым словом new должен следовать вызов функции. Применяемая подобным способом функция называется конструктором и предназначена для инициализации вновь созданного объекта.
- Object.create() - создает новый объект, используя в качестве его прототипа первый аргумент

## Запрашивание и установка свойства
Чтобы получить значение свойства, применяйте точку (.) или квадратные скобки ([]). В левой стороне должно быть выражение, значением которого является объект. Если используется точка, тогда с правой стороны должен находиться простой идентификатор, именующий свойства. В случае применения квадратных скобок значение внутри скобок должно быть выражением, вычисляемым в строку, которая содержит имя желаемого свойства.

## Удаление свойств
Операция delete удаляет свойство из объекта. Ее единственным операндом должно быть выражение доступа к свойству. Удивительно, но delete работает не со значением свойства, а с самим свойством.

## Проверка свойств
Объекты JavaScript можно рассматривать как наборы свойств и зачастую полезно иметь возможность проверять членство свойства в таком наборе. 
- Операция in ожидает с левой стороны имя свойства и с правой стороны объект. Она возвращает true, если объект имеет собственное или унаследованное свойство с указанным именем.
- Метод hasOwnProperty() объекта проверяет, имеет ли данный объект собственное свойство с заданным именем. Для унаследованных свойств он возвращает false.
- Метод propertyIsEnumerable() улучшает проверку hasOwnProperty(). Он возвращает true, только если именованное свойство является собственным и атрибут enumerable имеет значение true. Определенные встроенные свойства не поддерживают перечисление.

## Перечисление свойств
Вместо проверки индивидуальных свойств на предмет существования временами мы хотим пройти по ним или получить список всех свойств объекта. Цикл for/in выполняет тело цикла по одному разу для каждого перечислимого свойства указанного объекта, присваивая имя свойства переменной цикла. Встроенные методы, наследуемые объектами, не являются перечислимыми, но свойства, которые ваш код добавляет к объектам, по умолчанию будут перечислимыми.
В качестве альтернативы использованию цикла for/in часто легче плучить массив имен свойств для объекта и затем проходить по этому массиву в цикле for/of.
Есть четыре функции, которые можно применять для получения массива имен свойств.
- Функция Object.keys() возвращает массив имен перечислимых собственных свойств объекта. Она не включает не перечислимые свойства, унаследованные свойства или свойства с именами, представленными посредство значений Symbol.
- Функция Object.getOwnPropertyNames() работает подобно Object.keys(), но возвращает массив также имен не перечислимых собственных свойств при условии, что их имена представлены строками.
- Функция Object.getOwnPropertySymbols() возвращает собственные свойства, имена которых являются значениями Symbol, перечислимые они или нет.
- Функция Reflect.ownKeys() возвращает имена всех собственных свойств, перечислимых и не перечислимых, представленных как строками, так и значениями Symbol.

## Расширение объектов
Необходимость копирования свойств одного обхекта в другой - обычная операция в программах JavaScript. В версии ES6 эта возможность стала частью базового языка JavaScript в форме Object.assing()
- Функция Object.assign() - ожидает получения в своих аргументах двух и более объектов. Она модифицирует и возвращает первый аргумент, в котором указан целевой объект, но не изменяет второй и любой последующий аргумент, где указаны исходные объекты.

## Сериализация объектов
Сериализация объектов представляет собой процесс преобразования состояния объекта в строку, из которой позже он может быть восстановлен. Функции JSON.parse() и JSON.stringify() сериализируют и восстановливают объекты JavaScript.

## Методы Object
Все объекты JavaScript (кроме явно созданных без прототипа) наследуют свойства от Object.prototype. В текущем разделе объясняется несколько универсальных объектных методов, которые определены в Object.prototype, но предназначены для замены другими, более специализированным реализациями.
- Метод toString() не имеет аргументов, он возвращает строку, каким-то образом представляющую значение обхекта, на котором он вызван. Интерпретатор JavaScript вызывает данный метод всякий раз, когда объект необходимо преобразовать в строку, например при конкатенации строки с объектом.
- Метод toLocaleString() предназначен для возвращения локализованного строкового представления объекта. Стандартный метод toLocaleString(), определенный в Object, никакой локализации не делает: он просто вызывает метод toString() и возвращает его значение.
- Метод valueOf() во многом похож на метод toString(), но вызывается, когда интерпретатору JavaScript необходимо преобразовать объект в какой-то элементарный тип, отличающийся от строки - обычно в число. Интерпретатор JavaScript вызывает valueOf() автоматически, если объект используется в контексте, где требуется элементарное значение.
- Метод toJSON(). В Object.prototype на самом не определен метод toJSON(), но метод JSON.stringify() ищет метод toJSON() в каждом объекте, который нужно сериализировать. Если этот метод существует в объекте, подлежащем сериализации, тогда он вызывается и сериализируется его возвращаемое значение, а не первоначальное объект.